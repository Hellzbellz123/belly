use std::marker::PhantomData;

// use belly_core::relations::bind::{ToComponent, BindableSource, BindableTarget};
use bevy::{
    ecs::{
        query::{ReadOnlyWorldQuery, WorldQuery},
        storage::TableRow,
    },
    prelude::*,
};

fn main() {
    #[allow(unused_variables)]
    let w = register(btn);
    // println!("Widget: {}", btn.widget_name());
    // println!("W: {}", w.widget_name());
    // println!("Widgets::btn(), {}", Widgets::btn().widget_name());
}

// fn value<S: BindableSource + TransformableTo<f32>>(entity: Entity) -> ToComponent<BackgroundColor, S, Color> {
//     to!(entity, BackgroundColor:0|a)
// }

// use belly::{prelude::*, build::TransformableTo};
// fn t(e: Entity) {
//     // let x = from!(e, Transform:translation.x) >> to!(e, BackgroundColor:0|color.a);
//     // let x = to!(e, BackgroundColor:0|color.a);
// }

/// Defined in `belly_core::Widgets`, acts as global widgets namespace.
/// Custom widgets defines it own extension traits, such as
/// `ButtonWidgetExtension` with single method (`button()` for exmaple)
/// and implements this trait on the `Widgets` struct.
pub struct Widgets;

/// Context passed to [`BuildWidgetFunc::invoke_build_widget`]
pub struct WidgetContext;

/// Only the way I know to get the ref to the unit struct
pub trait Singleton: 'static {
    fn instance() -> &'static Self;
}

/// A tuple of component types. It us used for instantiating
/// set of components and bypassing them `&mut Components` into [`BuildWidgetFunc`]:
/// `invoke_build_widget(&mut ComponentA, &mut ComponentB)
pub trait Components {
    fn instantiate() -> Self;
}

/// [`Components`] implementation for diferent number of Conponent in tuple,
/// it is generated by macro
impl Components for () {
    fn instantiate() -> Self {}
}
impl<A: Component + Default> Components for (A,) {
    fn instantiate() -> Self {
        (A::default(),)
    }
}
impl<A: Component + Default, B: Component + Default> Components for (A, B) {
    fn instantiate() -> Self {
        (A::default(), B::default())
    }
}
impl<A: Component + Default, B: Component + Default, C: Component + Default> Components
    for (A, B, C)
{
    fn instantiate() -> Self {
        (A::default(), B::default(), C::default())
    }
}

/// Implementations of [`BuildWidgetFunc`] done by macro as well
pub trait BuildWidgetFunc<Params: Components>: 'static {
    fn invoke_build_widget(&self, ctx: &mut WidgetContext, params: &mut Params);
}

impl<F: Fn(&mut WidgetContext) + 'static> BuildWidgetFunc<()> for F {
    fn invoke_build_widget(&self, ctx: &mut WidgetContext, _params: &mut ()) {
        let () = _params;
        self(ctx)
    }
}
impl<F: Fn(&mut WidgetContext, &mut A) + 'static, A: Component + Default> BuildWidgetFunc<(A,)>
    for F
{
    fn invoke_build_widget(&self, ctx: &mut WidgetContext, params: &mut (A,)) {
        #[allow(non_snake_case)]
        let (A,) = params;
        self(ctx, A);
    }
}
impl<
        F: Fn(&mut WidgetContext, &mut A, &mut B) + 'static,
        A: Component + Default,
        B: Component + Default,
    > BuildWidgetFunc<(A, B)> for F
{
    fn invoke_build_widget(&self, ctx: &mut WidgetContext, params: &mut (A, B)) {
        let (a, b) = params;
        self(ctx, a, b);
    }
}

/// Unified Widget API
pub trait Widget {
    type Components: Components;
    type BindingsFrom: Singleton;
    type BindingsTo: Singleton;
    type ReadQuery: ReadOnlyWorldQuery + 'static;
    type WriteQuery: WorldQuery + 'static;

    fn instance() -> &'static Self;

    fn bind_from(&self) -> &Self::BindingsFrom {
        Self::BindingsFrom::instance()
    }
    fn bind_to(&self) -> &Self::BindingsTo {
        Self::BindingsTo::instance()
    }
    fn build_widget(&self, ctx: &mut WidgetContext, params: &mut Self::Components);
}

pub struct DefaultBindingsFrom;
impl Singleton for DefaultBindingsFrom {
    fn instance() -> &'static Self {
        &Self
    }
}
pub struct DefaultBindingsTo;
impl Singleton for DefaultBindingsTo {
    fn instance() -> &'static Self {
        &Self
    }
}

#[derive(Component)]
pub struct DefaultComponent;
#[derive(WorldQuery)]
#[world_query(mutable)]
pub struct DefaultQuery {
    unused_component: &'static mut DefaultComponent,
}

/// [`Widget`] can be implemented for funcs, it is done by macro as well:
// impl<F: BuildWidgetFunc<()>> Widget for F {
//     type BindingsFrom = DefaultBindingsFrom;
//     type BindingsTo = DefaultBindingsTo;
//     type WriteQuery = DefaultQuery;
//     type ReadQuery = <DefaultQuery as WorldQuery>::ReadOnly;
//     type Components = ();
//     fn instance() -> &'static Self {
//         let a = &Self;

//     }
// }

#[derive(Default, Component)]
pub struct Sld;
// #[widget]
// #[extends(prgs)]
// #[styles(prgs)]
// #[param(minimum:f32 => BackgroundColor:0|Color.a)]
// #[param(maximum:f32 => Range|minumum)]
// #[param(value:f32 => Range|minumum)]
// #[param(relative:f32 => Range|minumum)]
// // label
// #[signal(changed:BtnEvent, |e| e.pressed())]
// #[style(btn > .content {
//   margin: 25px;
// })]
pub fn btn(_ctx: &mut WidgetContext, _component: &mut Sld) {}

mod lbl_relations {
    use bevy::{ecs::query::WorldQuery, text::Text};

    pub struct BindingsFrom;
    impl super::Singleton for BindingsFrom {
        fn instance() -> &'static Self {
            &Self
        }
    }
    impl BindingsFrom {
        pub fn value(&self) {}
    }
    pub struct BindingsTo;
    impl super::Singleton for BindingsTo {
        fn instance() -> &'static Self {
            &Self
        }
    }
    impl BindingsTo {
        pub fn value(&self) {}
    }

    #[allow(dead_code)]
    pub struct Signals;
    impl Signals {}

    use bevy::prelude::*;
    #[derive(WorldQuery)]
    #[world_query(mutable)]
    pub struct Lbl {
        text: &'static mut Text,
    }

    impl<'w> LblReadOnlyItem<'w> {
        pub fn value(&self) -> &String {
            &self.text.sections[0].value
        }
    }
    impl<'w> LblItem<'w> {
        pub fn value(&self) -> &String {
            &self.text.sections[0].value
        }
        pub fn set_value(&mut self, value: String) {
            self.text.sections[0].value = value;
        }
    }
}

#[allow(dead_code, non_camel_case_types)]
pub struct lbl;
impl Widget for lbl {
    type Components = ();
    type BindingsFrom = lbl_relations::BindingsFrom;
    type BindingsTo = lbl_relations::BindingsTo;
    type ReadQuery = <lbl_relations::Lbl as WorldQuery>::ReadOnly;
    type WriteQuery = lbl_relations::Lbl;
    fn instance() -> &'static Self {
        &lbl
    }
    fn build_widget(&self, ctx: &mut WidgetContext, params: &mut Self::Components) {
        fn inner(_ctx: &mut WidgetContext) {}
        inner.invoke_build_widget(ctx, params)
    }
}

#[allow(dead_code)]
fn test_system(mut labels: Query<WidgetMut<lbl>>) {
    for mut label in labels.iter_mut() {
        println!("Value: {}", label.value());
        label.set_value("Hello".into());
    }
}

struct WidgetRef<T: Widget + 'static>(PhantomData<T>);
struct WidgetMut<T: Widget + 'static>(PhantomData<T>);

// fn tsystem(mut labels: Query<&lbl>) {
//     for label in labels.iter() {
//         let x = label.value();
//     }
// }
unsafe impl ReadOnlyWorldQuery for &'static lbl {}
unsafe impl WorldQuery for &lbl {
    type Fetch<'a> = <lbl_relations::LblReadOnly as WorldQuery>::Fetch<'a>;
    type Item<'a> = <lbl_relations::LblReadOnly as WorldQuery>::Item<'a>;
    type ReadOnly = &'static lbl;
    type State = <lbl_relations::LblReadOnly as WorldQuery>::State;

    fn shrink<'wlong: 'wshort, 'wshort>(item: Self::Item<'wlong>) -> Self::Item<'wshort> {
        lbl_relations::LblReadOnly::shrink(item)
    }
    unsafe fn init_fetch<'w>(
        world: &'w World,
        state: &Self::State,
        last_change_tick: u32,
        change_tick: u32,
    ) -> Self::Fetch<'w> {
        lbl_relations::LblReadOnly::init_fetch(world, state, last_change_tick, change_tick)
    }
    unsafe fn clone_fetch<'w>(fetch: &Self::Fetch<'w>) -> Self::Fetch<'w> {
        lbl_relations::LblReadOnly::clone_fetch(fetch)
    }
    unsafe fn set_archetype<'w>(
        fetch: &mut Self::Fetch<'w>,
        state: &Self::State,
        archetype: &'w bevy::ecs::archetype::Archetype,
        table: &'w bevy::ecs::storage::Table,
    ) {
        lbl_relations::LblReadOnly::set_archetype(fetch, state, archetype, table)
    }
    unsafe fn set_table<'w>(
        fetch: &mut Self::Fetch<'w>,
        state: &Self::State,
        table: &'w bevy::ecs::storage::Table,
    ) {
        lbl_relations::LblReadOnly::set_table(fetch, state, table)
    }
    unsafe fn fetch<'w>(
        fetch: &mut Self::Fetch<'w>,
        entity: Entity,
        table_row: TableRow,
    ) -> Self::Item<'w> {
        lbl_relations::LblReadOnly::fetch(fetch, entity, table_row)
    }
    unsafe fn filter_fetch(
        fetch: &mut Self::Fetch<'_>,
        entity: Entity,
        table_row: TableRow,
    ) -> bool {
        lbl_relations::LblReadOnly::filter_fetch(fetch, entity, table_row)
    }
    fn update_component_access(
        state: &Self::State,
        access: &mut bevy::ecs::query::FilteredAccess<bevy::ecs::component::ComponentId>,
    ) {
        lbl_relations::LblReadOnly::update_component_access(state, access)
    }
    fn update_archetype_component_access(
        state: &Self::State,
        archetype: &bevy::ecs::archetype::Archetype,
        access: &mut bevy::ecs::query::Access<bevy::ecs::archetype::ArchetypeComponentId>,
    ) {
        lbl_relations::LblReadOnly::update_archetype_component_access(state, archetype, access)
    }
    fn init_state(world: &mut World) -> Self::State {
        lbl_relations::LblReadOnly::init_state(world)
    }
    fn matches_component_set(
        state: &Self::State,
        set_contains_id: &impl Fn(bevy::ecs::component::ComponentId) -> bool,
    ) -> bool {
        lbl_relations::LblReadOnly::matches_component_set(state, set_contains_id)
    }
    const IS_DENSE: bool = <lbl_relations::LblReadOnly as WorldQuery>::IS_DENSE;
    const IS_ARCHETYPAL: bool = <lbl_relations::LblReadOnly as WorldQuery>::IS_ARCHETYPAL;
}
unsafe impl WorldQuery for &mut lbl {
    type Fetch<'a> = <lbl_relations::Lbl as WorldQuery>::Fetch<'a>;
    type Item<'a> = <lbl_relations::Lbl as WorldQuery>::Item<'a>;
    type ReadOnly = <lbl_relations::Lbl as WorldQuery>::ReadOnly;
    type State = <lbl_relations::Lbl as WorldQuery>::State;

    fn shrink<'wlong: 'wshort, 'wshort>(item: Self::Item<'wlong>) -> Self::Item<'wshort> {
        lbl_relations::Lbl::shrink(item)
    }
    unsafe fn init_fetch<'w>(
        world: &'w World,
        state: &Self::State,
        last_change_tick: u32,
        change_tick: u32,
    ) -> Self::Fetch<'w> {
        lbl_relations::Lbl::init_fetch(world, state, last_change_tick, change_tick)
    }
    unsafe fn clone_fetch<'w>(fetch: &Self::Fetch<'w>) -> Self::Fetch<'w> {
        lbl_relations::Lbl::clone_fetch(fetch)
    }
    unsafe fn set_archetype<'w>(
        fetch: &mut Self::Fetch<'w>,
        state: &Self::State,
        archetype: &'w bevy::ecs::archetype::Archetype,
        table: &'w bevy::ecs::storage::Table,
    ) {
        lbl_relations::Lbl::set_archetype(fetch, state, archetype, table)
    }
    unsafe fn set_table<'w>(
        fetch: &mut Self::Fetch<'w>,
        state: &Self::State,
        table: &'w bevy::ecs::storage::Table,
    ) {
        lbl_relations::Lbl::set_table(fetch, state, table)
    }
    unsafe fn fetch<'w>(
        fetch: &mut Self::Fetch<'w>,
        entity: Entity,
        table_row: TableRow,
    ) -> Self::Item<'w> {
        lbl_relations::Lbl::fetch(fetch, entity, table_row)
    }
    unsafe fn filter_fetch(
        fetch: &mut Self::Fetch<'_>,
        entity: Entity,
        table_row: TableRow,
    ) -> bool {
        lbl_relations::Lbl::filter_fetch(fetch, entity, table_row)
    }
    fn update_component_access(
        state: &Self::State,
        access: &mut bevy::ecs::query::FilteredAccess<bevy::ecs::component::ComponentId>,
    ) {
        lbl_relations::Lbl::update_component_access(state, access)
    }
    fn update_archetype_component_access(
        state: &Self::State,
        archetype: &bevy::ecs::archetype::Archetype,
        access: &mut bevy::ecs::query::Access<bevy::ecs::archetype::ArchetypeComponentId>,
    ) {
        lbl_relations::Lbl::update_archetype_component_access(state, archetype, access)
    }
    fn init_state(world: &mut World) -> Self::State {
        lbl_relations::Lbl::init_state(world)
    }
    fn matches_component_set(
        state: &Self::State,
        set_contains_id: &impl Fn(bevy::ecs::component::ComponentId) -> bool,
    ) -> bool {
        lbl_relations::Lbl::matches_component_set(state, set_contains_id)
    }
    const IS_DENSE: bool = <lbl_relations::Lbl as WorldQuery>::IS_DENSE;
    const IS_ARCHETYPAL: bool = <lbl_relations::Lbl as WorldQuery>::IS_ARCHETYPAL;
}

unsafe impl<T: Widget> WorldQuery for WidgetRef<T> {
    type Fetch<'a> = <<T as Widget>::ReadQuery as WorldQuery>::Fetch<'a>;
    type Item<'a> = <<T as Widget>::ReadQuery as WorldQuery>::Item<'a>;
    type ReadOnly = <<T as Widget>::ReadQuery as WorldQuery>::ReadOnly;
    type State = <<T as Widget>::ReadQuery as WorldQuery>::State;

    fn shrink<'wlong: 'wshort, 'wshort>(item: Self::Item<'wlong>) -> Self::Item<'wshort> {
        T::ReadQuery::shrink(item)
    }
    unsafe fn init_fetch<'w>(
        world: &'w World,
        state: &Self::State,
        last_change_tick: u32,
        change_tick: u32,
    ) -> Self::Fetch<'w> {
        T::ReadQuery::init_fetch(world, state, last_change_tick, change_tick)
    }
    unsafe fn clone_fetch<'w>(fetch: &Self::Fetch<'w>) -> Self::Fetch<'w> {
        T::ReadQuery::clone_fetch(fetch)
    }
    unsafe fn set_archetype<'w>(
        fetch: &mut Self::Fetch<'w>,
        state: &Self::State,
        archetype: &'w bevy::ecs::archetype::Archetype,
        table: &'w bevy::ecs::storage::Table,
    ) {
        T::ReadQuery::set_archetype(fetch, state, archetype, table)
    }
    unsafe fn set_table<'w>(
        fetch: &mut Self::Fetch<'w>,
        state: &Self::State,
        table: &'w bevy::ecs::storage::Table,
    ) {
        T::ReadQuery::set_table(fetch, state, table)
    }
    unsafe fn fetch<'w>(
        fetch: &mut Self::Fetch<'w>,
        entity: Entity,
        table_row: TableRow,
    ) -> Self::Item<'w> {
        T::ReadQuery::fetch(fetch, entity, table_row)
    }
    unsafe fn filter_fetch(
        fetch: &mut Self::Fetch<'_>,
        entity: Entity,
        table_row: TableRow,
    ) -> bool {
        T::ReadQuery::filter_fetch(fetch, entity, table_row)
    }
    fn update_component_access(
        state: &Self::State,
        access: &mut bevy::ecs::query::FilteredAccess<bevy::ecs::component::ComponentId>,
    ) {
        T::ReadQuery::update_component_access(state, access)
    }
    fn update_archetype_component_access(
        state: &Self::State,
        archetype: &bevy::ecs::archetype::Archetype,
        access: &mut bevy::ecs::query::Access<bevy::ecs::archetype::ArchetypeComponentId>,
    ) {
        T::ReadQuery::update_archetype_component_access(state, archetype, access)
    }
    fn init_state(world: &mut World) -> Self::State {
        T::ReadQuery::init_state(world)
    }
    fn matches_component_set(
        state: &Self::State,
        set_contains_id: &impl Fn(bevy::ecs::component::ComponentId) -> bool,
    ) -> bool {
        T::ReadQuery::matches_component_set(state, set_contains_id)
    }
    const IS_DENSE: bool = <T::ReadQuery as WorldQuery>::IS_DENSE;
    const IS_ARCHETYPAL: bool = <T::ReadQuery as WorldQuery>::IS_ARCHETYPAL;
}

unsafe impl<T: Widget> WorldQuery for WidgetMut<T> {
    type Fetch<'a> = <<T as Widget>::WriteQuery as WorldQuery>::Fetch<'a>;
    type Item<'a> = <<T as Widget>::WriteQuery as WorldQuery>::Item<'a>;
    type ReadOnly = <<T as Widget>::WriteQuery as WorldQuery>::ReadOnly;
    type State = <<T as Widget>::WriteQuery as WorldQuery>::State;

    fn shrink<'wlong: 'wshort, 'wshort>(item: Self::Item<'wlong>) -> Self::Item<'wshort> {
        T::WriteQuery::shrink(item)
    }
    unsafe fn init_fetch<'w>(
        world: &'w World,
        state: &Self::State,
        last_change_tick: u32,
        change_tick: u32,
    ) -> Self::Fetch<'w> {
        T::WriteQuery::init_fetch(world, state, last_change_tick, change_tick)
    }
    unsafe fn clone_fetch<'w>(fetch: &Self::Fetch<'w>) -> Self::Fetch<'w> {
        T::WriteQuery::clone_fetch(fetch)
    }
    unsafe fn set_archetype<'w>(
        fetch: &mut Self::Fetch<'w>,
        state: &Self::State,
        archetype: &'w bevy::ecs::archetype::Archetype,
        table: &'w bevy::ecs::storage::Table,
    ) {
        T::WriteQuery::set_archetype(fetch, state, archetype, table)
    }
    unsafe fn set_table<'w>(
        fetch: &mut Self::Fetch<'w>,
        state: &Self::State,
        table: &'w bevy::ecs::storage::Table,
    ) {
        T::WriteQuery::set_table(fetch, state, table)
    }
    unsafe fn fetch<'w>(
        fetch: &mut Self::Fetch<'w>,
        entity: Entity,
        table_row: TableRow,
    ) -> Self::Item<'w> {
        T::WriteQuery::fetch(fetch, entity, table_row)
    }
    unsafe fn filter_fetch(
        fetch: &mut Self::Fetch<'_>,
        entity: Entity,
        table_row: TableRow,
    ) -> bool {
        T::WriteQuery::filter_fetch(fetch, entity, table_row)
    }
    fn update_component_access(
        state: &Self::State,
        access: &mut bevy::ecs::query::FilteredAccess<bevy::ecs::component::ComponentId>,
    ) {
        T::WriteQuery::update_component_access(state, access)
    }
    fn update_archetype_component_access(
        state: &Self::State,
        archetype: &bevy::ecs::archetype::Archetype,
        access: &mut bevy::ecs::query::Access<bevy::ecs::archetype::ArchetypeComponentId>,
    ) {
        T::WriteQuery::update_archetype_component_access(state, archetype, access)
    }
    fn init_state(world: &mut World) -> Self::State {
        T::WriteQuery::init_state(world)
    }
    fn matches_component_set(
        state: &Self::State,
        set_contains_id: &impl Fn(bevy::ecs::component::ComponentId) -> bool,
    ) -> bool {
        T::WriteQuery::matches_component_set(state, set_contains_id)
    }
    const IS_DENSE: bool = T::WriteQuery::IS_DENSE;
    const IS_ARCHETYPAL: bool = T::WriteQuery::IS_ARCHETYPAL;
}

// impl<T: Widget> WorldQuery for WidgetRef<T> {
//     type Item<'a> = ;
// }

pub trait LblWidgetExtension {
    #[doc = "Hello!"]
    #[doc = format!("{}", lbl_relations::BindingsTo::DOCS)]
    fn lbl() -> &'static lbl {
        &lbl
    }
}
impl LblWidgetExtension for Widgets {}

#[allow(dead_code)]
fn test_lbl() {
    Widgets::lbl().bind_from().value();
    // Widgets::label::instance();
}
// // #[widget]
// // #[param(value => Text:sections[0].value)]
// pub fn lbl() {

// }

pub trait BtnWidgetExtension {
    fn btn() -> &'static dyn BuildWidgetFunc<(Sld,)> {
        &btn
    }
}
impl BtnWidgetExtension for Widgets {}

pub fn register<T: BuildWidgetFunc<Params> + 'static, Params: Components>(
    func: T,
) -> Box<dyn BuildWidgetFunc<Params>> {
    Widgets::lbl();
    Box::new(func)
}
